using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.Drawing.Text;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Real_Time_Screen_Filters
{
    internal static class Program
    {
        internal static readonly string Texto_Fecha = "2020_02_10_19_34_42_198"; // First created at: 2020_02_06_13_20_05_641.
        internal static string Texto_Usuario = Environment.UserName;
        internal static string Texto_Título = "Real Time Screen Filters by Jupisoft";
        internal static string Texto_Programa = "Real Time Screen Filters";
        internal static readonly string Texto_Versión = "1.0";
        internal static readonly string Texto_Versión_Fecha = Texto_Versión + " (" + Texto_Fecha/*.Replace("_", null)*/ + ")";
        internal static string Texto_Título_Versión = Texto_Título + " " + Texto_Versión;

        /// <summary>
        /// Using this icon instead of adding it to the designer of each form saved almost 11 MB of space in my Minecraft Tools application.
        /// </summary>
        internal static Icon Icono_Jupisoft = null;

        internal static Random Rand = new Random();
        internal static Kuiper.Clerom.Xoroshiro128p Rand_Xoroshiro128p = new Kuiper.Clerom.Xoroshiro128p(true);
        internal static readonly char Caracter_Coma_Decimal = (0.5d).ToString()[1];
        internal static Process Proceso = Process.GetCurrentProcess();
        internal static PerformanceCounter Rendimiento_Procesador = null;

        /// <summary>
        /// Byte array that holds up the 256 byte values modified with the inverted square root function. Useful to give darkness to any image.
        /// </summary>
        internal static readonly byte[] Matriz_Bytes_Filtro_Raíz_Cuadrada_Menos = new byte[256] { 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 29, 29, 30, 30, 31, 31, 32, 33, 33, 34, 34, 35, 35, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 44, 45, 46, 46, 47, 47, 48, 49, 49, 50, 51, 51, 52, 52, 53, 54, 54, 55, 56, 56, 57, 57, 58, 59, 59, 60, 61, 61, 62, 63, 63, 64, 65, 65, 66, 67, 67, 68, 69, 69, 70, 71, 72, 72, 73, 74, 74, 75, 76, 76, 77, 78, 79, 79, 80, 81, 82, 82, 83, 84, 85, 85, 86, 87, 88, 88, 89, 90, 91, 91, 92, 93, 94, 95, 95, 96, 97, 98, 99, 99, 100, 101, 102, 103, 104, 104, 105, 106, 107, 108, 109, 110, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 136, 137, 138, 139, 140, 141, 142, 143, 144, 146, 147, 148, 149, 150, 152, 153, 154, 155, 157, 158, 159, 161, 162, 163, 165, 166, 168, 169, 171, 172, 174, 175, 177, 178, 180, 182, 184, 185, 187, 189, 191, 193, 195, 197, 200, 202, 205, 207, 210, 213, 216, 219, 223, 227, 232, 239, 255 };
        /// <summary>
        /// Byte array that holds up the 256 byte values modified with the square root function. Useful to give brightness to any image.
        /// </summary>
        internal static readonly byte[] Matriz_Bytes_Filtro_Raíz_Cuadrada = new byte[256] { 0, 16, 23, 28, 32, 36, 39, 42, 45, 48, 50, 53, 55, 58, 60, 62, 64, 66, 68, 70, 71, 73, 75, 77, 78, 80, 81, 83, 84, 86, 87, 89, 90, 92, 93, 94, 96, 97, 98, 100, 101, 102, 103, 105, 106, 107, 108, 109, 111, 112, 113, 114, 115, 116, 117, 118, 119, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 145, 146, 147, 148, 149, 150, 151, 151, 152, 153, 154, 155, 156, 156, 157, 158, 159, 160, 160, 161, 162, 163, 164, 164, 165, 166, 167, 167, 168, 169, 170, 170, 171, 172, 173, 173, 174, 175, 176, 176, 177, 178, 179, 179, 180, 181, 181, 182, 183, 183, 184, 185, 186, 186, 187, 188, 188, 189, 190, 190, 191, 192, 192, 193, 194, 194, 195, 196, 196, 197, 198, 198, 199, 199, 200, 201, 201, 202, 203, 203, 204, 204, 205, 206, 206, 207, 208, 208, 209, 209, 210, 211, 211, 212, 212, 213, 214, 214, 215, 215, 216, 217, 217, 218, 218, 219, 220, 220, 221, 221, 222, 222, 223, 224, 224, 225, 225, 226, 226, 227, 228, 228, 229, 229, 230, 230, 231, 231, 232, 233, 233, 234, 234, 235, 235, 236, 236, 237, 237, 238, 238, 239, 240, 240, 241, 241, 242, 242, 243, 243, 244, 244, 245, 245, 246, 246, 247, 247, 248, 248, 249, 249, 250, 250, 251, 251, 252, 252, 253, 253, 254, 254, 255 };
        /// <summary>
        /// Byte array that holds up the 256 byte values modified with the inverted logarithm function. Useful to give extra darkness to any image.
        /// </summary>
        internal static readonly byte[] Matriz_Bytes_Filtro_Logaritmo_Menos = new byte[256] { 0, 0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 27, 27, 27, 28, 28, 28, 29, 29, 29, 30, 30, 30, 31, 31, 31, 32, 32, 32, 33, 33, 33, 34, 34, 35, 35, 35, 36, 36, 37, 37, 37, 38, 38, 39, 39, 39, 40, 40, 41, 41, 42, 42, 42, 43, 43, 44, 44, 45, 45, 46, 46, 47, 47, 48, 48, 49, 49, 50, 50, 51, 51, 52, 53, 53, 54, 54, 55, 55, 56, 57, 57, 58, 59, 59, 60, 61, 61, 62, 63, 63, 64, 65, 65, 66, 67, 68, 69, 69, 70, 71, 72, 73, 74, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 85, 86, 87, 88, 89, 91, 92, 93, 95, 96, 97, 99, 101, 102, 104, 106, 107, 109, 111, 113, 115, 118, 120, 123, 125, 128, 131, 134, 138, 141, 145, 150, 155, 160, 166, 173, 182, 192, 205, 224, 255 };
        /// <summary>
        /// Byte array that holds up the 256 byte values modified with the logarithm function. Useful to give extra brightness to any image.
        /// </summary>
        internal static readonly byte[] Matriz_Bytes_Filtro_Logaritmo = new byte[256] { 0, 31, 50, 63, 73, 82, 89, 95, 100, 105, 110, 114, 117, 121, 124, 127, 130, 132, 135, 137, 140, 142, 144, 146, 148, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 164, 166, 167, 168, 169, 170, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 181, 182, 183, 184, 185, 186, 186, 187, 188, 189, 190, 190, 191, 192, 192, 193, 194, 194, 195, 196, 196, 197, 198, 198, 199, 200, 200, 201, 201, 202, 202, 203, 204, 204, 205, 205, 206, 206, 207, 207, 208, 208, 209, 209, 210, 210, 211, 211, 212, 212, 213, 213, 213, 214, 214, 215, 215, 216, 216, 216, 217, 217, 218, 218, 218, 219, 219, 220, 220, 220, 221, 221, 222, 222, 222, 223, 223, 223, 224, 224, 224, 225, 225, 225, 226, 226, 226, 227, 227, 227, 228, 228, 228, 229, 229, 229, 230, 230, 230, 231, 231, 231, 232, 232, 232, 232, 233, 233, 233, 234, 234, 234, 234, 235, 235, 235, 236, 236, 236, 236, 237, 237, 237, 237, 238, 238, 238, 238, 239, 239, 239, 240, 240, 240, 240, 241, 241, 241, 241, 241, 242, 242, 242, 242, 243, 243, 243, 243, 244, 244, 244, 244, 245, 245, 245, 245, 245, 246, 246, 246, 246, 247, 247, 247, 247, 247, 248, 248, 248, 248, 248, 249, 249, 249, 249, 249, 250, 250, 250, 250, 250, 251, 251, 251, 251, 251, 252, 252, 252, 252, 252, 253, 253, 253, 253, 253, 254, 254, 254, 254, 254, 254, 255, 255, 255 };
        /// <summary>
        /// Byte array that holds up the 256 byte values modified with the base 2 bit inversion function. This filter can be undone by using it a second time.
        /// </summary>
        internal static readonly byte[] Matriz_Bytes_Filtro_Invertir_Bits_Base_2 = new byte[256] { 0, 128, 64, 192, 32, 160, 96, 224, 16, 144, 80, 208, 48, 176, 112, 240, 8, 136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248, 4, 132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244, 12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252, 2, 130, 66, 194, 34, 162, 98, 226, 18, 146, 82, 210, 50, 178, 114, 242, 10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250, 6, 134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246, 14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254, 1, 129, 65, 193, 33, 161, 97, 225, 17, 145, 81, 209, 49, 177, 113, 241, 9, 137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249, 5, 133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245, 13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253, 3, 131, 67, 195, 35, 163, 99, 227, 19, 147, 83, 211, 51, 179, 115, 243, 11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251, 7, 135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247, 15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255 };
        /// <summary>
        /// Byte array that holds up the 256 byte values modified with the base 4 bit inversion function. This filter can be undone by using it a second time.
        /// </summary>
        internal static readonly byte[] Matriz_Bytes_Filtro_Invertir_Bits_Base_4 = new byte[256] { 0, 64, 128, 192, 16, 80, 144, 208, 32, 96, 160, 224, 48, 112, 176, 240, 4, 68, 132, 196, 20, 84, 148, 212, 36, 100, 164, 228, 52, 116, 180, 244, 8, 72, 136, 200, 24, 88, 152, 216, 40, 104, 168, 232, 56, 120, 184, 248, 12, 76, 140, 204, 28, 92, 156, 220, 44, 108, 172, 236, 60, 124, 188, 252, 1, 65, 129, 193, 17, 81, 145, 209, 33, 97, 161, 225, 49, 113, 177, 241, 5, 69, 133, 197, 21, 85, 149, 213, 37, 101, 165, 229, 53, 117, 181, 245, 9, 73, 137, 201, 25, 89, 153, 217, 41, 105, 169, 233, 57, 121, 185, 249, 13, 77, 141, 205, 29, 93, 157, 221, 45, 109, 173, 237, 61, 125, 189, 253, 2, 66, 130, 194, 18, 82, 146, 210, 34, 98, 162, 226, 50, 114, 178, 242, 6, 70, 134, 198, 22, 86, 150, 214, 38, 102, 166, 230, 54, 118, 182, 246, 10, 74, 138, 202, 26, 90, 154, 218, 42, 106, 170, 234, 58, 122, 186, 250, 14, 78, 142, 206, 30, 94, 158, 222, 46, 110, 174, 238, 62, 126, 190, 254, 3, 67, 131, 195, 19, 83, 147, 211, 35, 99, 163, 227, 51, 115, 179, 243, 7, 71, 135, 199, 23, 87, 151, 215, 39, 103, 167, 231, 55, 119, 183, 247, 11, 75, 139, 203, 27, 91, 155, 219, 43, 107, 171, 235, 59, 123, 187, 251, 15, 79, 143, 207, 31, 95, 159, 223, 47, 111, 175, 239, 63, 127, 191, 255 };
        /// <summary>
        /// Byte array that holds up the 256 byte values modified with the base 16 bit inversion function. This filter can be undone by using it a second time.
        /// </summary>
        internal static readonly byte[] Matriz_Bytes_Filtro_Invertir_Bits_Base_16 = new byte[256] { 0, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 1, 17, 33, 49, 65, 81, 97, 113, 129, 145, 161, 177, 193, 209, 225, 241, 2, 18, 34, 50, 66, 82, 98, 114, 130, 146, 162, 178, 194, 210, 226, 242, 3, 19, 35, 51, 67, 83, 99, 115, 131, 147, 163, 179, 195, 211, 227, 243, 4, 20, 36, 52, 68, 84, 100, 116, 132, 148, 164, 180, 196, 212, 228, 244, 5, 21, 37, 53, 69, 85, 101, 117, 133, 149, 165, 181, 197, 213, 229, 245, 6, 22, 38, 54, 70, 86, 102, 118, 134, 150, 166, 182, 198, 214, 230, 246, 7, 23, 39, 55, 71, 87, 103, 119, 135, 151, 167, 183, 199, 215, 231, 247, 8, 24, 40, 56, 72, 88, 104, 120, 136, 152, 168, 184, 200, 216, 232, 248, 9, 25, 41, 57, 73, 89, 105, 121, 137, 153, 169, 185, 201, 217, 233, 249, 10, 26, 42, 58, 74, 90, 106, 122, 138, 154, 170, 186, 202, 218, 234, 250, 11, 27, 43, 59, 75, 91, 107, 123, 139, 155, 171, 187, 203, 219, 235, 251, 12, 28, 44, 60, 76, 92, 108, 124, 140, 156, 172, 188, 204, 220, 236, 252, 13, 29, 45, 61, 77, 93, 109, 125, 141, 157, 173, 189, 205, 221, 237, 253, 14, 30, 46, 62, 78, 94, 110, 126, 142, 158, 174, 190, 206, 222, 238, 254, 15, 31, 47, 63, 79, 95, 111, 127, 143, 159, 175, 191, 207, 223, 239, 255 };
        /// <summary>
        /// Byte array that holds up the 256 byte values modified with the negative function. This filter can be undone by using it a second time.
        /// </summary>
        internal static readonly byte[] Matriz_Bytes_Filtro_Negativo = new byte[256] { 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199, 198, 197, 196, 195, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 170, 169, 168, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 157, 156, 155, 154, 153, 152, 151, 150, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 };

        /*internal static readonly byte[] Matriz_Bytes_Filtro_Posterizar_2 = new byte[256] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
        internal static readonly byte[] Matriz_Bytes_Filtro_ = new byte[256] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
        internal static readonly byte[] Matriz_Bytes_Filtro_ = new byte[256] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 145, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
        internal static readonly byte[] Matriz_Bytes_Filtro_ = new byte[256] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
        internal static readonly byte[] Matriz_Bytes_Filtro_ = new byte[256] { 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16, 16, 16, 16, 16, 16, 16, 24, 24, 24, 24, 24, 24, 24, 24, 32, 32, 32, 32, 32, 32, 32, 32, 41, 41, 41, 41, 41, 41, 41, 41, 49, 49, 49, 49, 49, 49, 49, 49, 57, 57, 57, 57, 57, 57, 57, 57, 65, 65, 65, 65, 65, 65, 65, 65, 74, 74, 74, 74, 74, 74, 74, 74, 82, 82, 82, 82, 82, 82, 82, 82, 90, 90, 90, 90, 90, 90, 90, 90, 98, 98, 98, 98, 98, 98, 98, 98, 106, 106, 106, 106, 106, 106, 106, 106, 115, 115, 115, 115, 115, 115, 115, 115, 123, 123, 123, 123, 123, 123, 123, 123, 131, 131, 131, 131, 131, 131, 131, 131, 139, 139, 139, 139, 139, 139, 139, 139, 148, 148, 148, 148, 148, 148, 148, 148, 156, 156, 156, 156, 156, 156, 156, 156, 164, 164, 164, 164, 164, 164, 164, 164, 172, 172, 172, 172, 172, 172, 172, 172, 180, 180, 180, 180, 180, 180, 180, 180, 189, 189, 189, 189, 189, 189, 189, 189, 197, 197, 197, 197, 197, 197, 197, 197, 205, 205, 205, 205, 205, 205, 205, 205, 213, 213, 213, 213, 213, 213, 213, 213, 222, 222, 222, 222, 222, 222, 222, 222, 230, 230, 230, 230, 230, 230, 230, 230, 238, 238, 238, 238, 238, 238, 238, 238, 246, 246, 246, 246, 246, 246, 246, 246, 255, 255, 255, 255, 255, 255, 255, 255 };
        internal static readonly byte[] Matriz_Bytes_Filtro_ = new byte[256] { 0, 0, 0, 0, 4, 4, 4, 4, 8, 8, 8, 8, 12, 12, 12, 12, 16, 16, 16, 16, 20, 20, 20, 20, 24, 24, 24, 24, 28, 28, 28, 28, 32, 32, 32, 32, 36, 36, 36, 36, 40, 40, 40, 40, 44, 44, 44, 44, 48, 48, 48, 48, 52, 52, 52, 52, 56, 56, 56, 56, 60, 60, 60, 60, 64, 64, 64, 64, 68, 68, 68, 68, 72, 72, 72, 72, 76, 76, 76, 76, 80, 80, 80, 80, 85, 85, 85, 85, 89, 89, 89, 89, 93, 93, 93, 93, 97, 97, 97, 97, 101, 101, 101, 101, 105, 105, 105, 105, 109, 109, 109, 109, 113, 113, 113, 113, 117, 117, 117, 117, 121, 121, 121, 121, 125, 125, 125, 125, 129, 129, 129, 129, 133, 133, 133, 133, 137, 137, 137, 137, 141, 141, 141, 141, 145, 145, 145, 145, 149, 149, 149, 149, 153, 153, 153, 153, 157, 157, 157, 157, 161, 161, 161, 161, 165, 165, 165, 165, 170, 170, 170, 170, 174, 174, 174, 174, 178, 178, 178, 178, 182, 182, 182, 182, 186, 186, 186, 186, 190, 190, 190, 190, 194, 194, 194, 194, 198, 198, 198, 198, 202, 202, 202, 202, 206, 206, 206, 206, 210, 210, 210, 210, 214, 214, 214, 214, 218, 218, 218, 218, 222, 222, 222, 222, 226, 226, 226, 226, 230, 230, 230, 230, 234, 234, 234, 234, 238, 238, 238, 238, 242, 242, 242, 242, 246, 246, 246, 246, 250, 250, 250, 250, 255, 255, 255, 255 };
        internal static readonly byte[] Matriz_Bytes_Filtro_ = new byte[256] { 0, 0, 2, 2, 4, 4, 6, 6, 8, 8, 10, 10, 12, 12, 14, 14, 16, 16, 18, 18, 20, 20, 22, 22, 24, 24, 26, 26, 28, 28, 30, 30, 32, 32, 34, 34, 36, 36, 38, 38, 40, 40, 42, 42, 44, 44, 46, 46, 48, 48, 50, 50, 52, 52, 54, 54, 56, 56, 58, 58, 60, 60, 62, 62, 64, 64, 66, 66, 68, 68, 70, 70, 72, 72, 74, 74, 76, 76, 78, 78, 80, 80, 82, 82, 84, 84, 86, 86, 88, 88, 90, 90, 92, 92, 94, 94, 96, 96, 98, 98, 100, 100, 102, 102, 104, 104, 106, 106, 108, 108, 110, 110, 112, 112, 114, 114, 116, 116, 118, 118, 120, 120, 122, 122, 124, 124, 126, 126, 128, 128, 130, 130, 132, 132, 134, 134, 136, 136, 138, 138, 140, 140, 142, 142, 144, 144, 146, 146, 148, 148, 150, 150, 152, 152, 154, 154, 156, 156, 158, 158, 160, 160, 162, 162, 164, 164, 166, 166, 168, 168, 170, 170, 172, 172, 174, 174, 176, 176, 178, 178, 180, 180, 182, 182, 184, 184, 186, 186, 188, 188, 190, 190, 192, 192, 194, 194, 196, 196, 198, 198, 200, 200, 202, 202, 204, 204, 206, 206, 208, 208, 210, 210, 212, 212, 214, 214, 216, 216, 218, 218, 220, 220, 222, 222, 224, 224, 226, 226, 228, 228, 230, 230, 232, 232, 234, 234, 236, 236, 238, 238, 240, 240, 242, 242, 244, 244, 246, 246, 248, 248, 250, 250, 252, 252, 255, 255 };
        */
        internal static readonly byte[] Matriz_Bytes_Filtro_Posterizar_2 = new byte[256] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
        internal static readonly byte[] Matriz_Bytes_Filtro_Posterizar_4 = new byte[256] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
        internal static readonly byte[] Matriz_Bytes_Filtro_Posterizar_8 = new byte[256] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 36, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 73, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 109, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 146, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 182, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 219, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
        internal static readonly byte[] Matriz_Bytes_Filtro_Posterizar_16 = new byte[256] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 170, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 };
        internal static readonly byte[] Matriz_Bytes_Filtro_Posterizar_32 = new byte[256] { 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16, 16, 16, 16, 16, 16, 16, 25, 25, 25, 25, 25, 25, 25, 25, 33, 33, 33, 33, 33, 33, 33, 33, 41, 41, 41, 41, 41, 41, 41, 41, 49, 49, 49, 49, 49, 49, 49, 49, 58, 58, 58, 58, 58, 58, 58, 58, 66, 66, 66, 66, 66, 66, 66, 66, 74, 74, 74, 74, 74, 74, 74, 74, 82, 82, 82, 82, 82, 82, 82, 82, 90, 90, 90, 90, 90, 90, 90, 90, 99, 99, 99, 99, 99, 99, 99, 99, 107, 107, 107, 107, 107, 107, 107, 107, 115, 115, 115, 115, 115, 115, 115, 115, 123, 123, 123, 123, 123, 123, 123, 123, 132, 132, 132, 132, 132, 132, 132, 132, 140, 140, 140, 140, 140, 140, 140, 140, 148, 148, 148, 148, 148, 148, 148, 148, 156, 156, 156, 156, 156, 156, 156, 156, 165, 165, 165, 165, 165, 165, 165, 165, 173, 173, 173, 173, 173, 173, 173, 173, 181, 181, 181, 181, 181, 181, 181, 181, 189, 189, 189, 189, 189, 189, 189, 189, 197, 197, 197, 197, 197, 197, 197, 197, 206, 206, 206, 206, 206, 206, 206, 206, 214, 214, 214, 214, 214, 214, 214, 214, 222, 222, 222, 222, 222, 222, 222, 222, 230, 230, 230, 230, 230, 230, 230, 230, 239, 239, 239, 239, 239, 239, 239, 239, 247, 247, 247, 247, 247, 247, 247, 247, 255, 255, 255, 255, 255, 255, 255, 255 };
        internal static readonly byte[] Matriz_Bytes_Filtro_Posterizar_64 = new byte[256] { 0, 0, 0, 0, 4, 4, 4, 4, 8, 8, 8, 8, 12, 12, 12, 12, 16, 16, 16, 16, 20, 20, 20, 20, 24, 24, 24, 24, 28, 28, 28, 28, 32, 32, 32, 32, 36, 36, 36, 36, 40, 40, 40, 40, 45, 45, 45, 45, 49, 49, 49, 49, 53, 53, 53, 53, 57, 57, 57, 57, 61, 61, 61, 61, 65, 65, 65, 65, 69, 69, 69, 69, 73, 73, 73, 73, 77, 77, 77, 77, 81, 81, 81, 81, 85, 85, 85, 85, 89, 89, 89, 89, 93, 93, 93, 93, 97, 97, 97, 97, 101, 101, 101, 101, 105, 105, 105, 105, 109, 109, 109, 109, 113, 113, 113, 113, 117, 117, 117, 117, 121, 121, 121, 121, 125, 125, 125, 125, 130, 130, 130, 130, 134, 134, 134, 134, 138, 138, 138, 138, 142, 142, 142, 142, 146, 146, 146, 146, 150, 150, 150, 150, 154, 154, 154, 154, 158, 158, 158, 158, 162, 162, 162, 162, 166, 166, 166, 166, 170, 170, 170, 170, 174, 174, 174, 174, 178, 178, 178, 178, 182, 182, 182, 182, 186, 186, 186, 186, 190, 190, 190, 190, 194, 194, 194, 194, 198, 198, 198, 198, 202, 202, 202, 202, 206, 206, 206, 206, 210, 210, 210, 210, 215, 215, 215, 215, 219, 219, 219, 219, 223, 223, 223, 223, 227, 227, 227, 227, 231, 231, 231, 231, 235, 235, 235, 235, 239, 239, 239, 239, 243, 243, 243, 243, 247, 247, 247, 247, 251, 251, 251, 251, 255, 255, 255, 255 };
        internal static readonly byte[] Matriz_Bytes_Filtro_Posterizar_128 = new byte[256] { 0, 0, 2, 2, 4, 4, 6, 6, 8, 8, 10, 10, 12, 12, 14, 14, 16, 16, 18, 18, 20, 20, 22, 22, 24, 24, 26, 26, 28, 28, 30, 30, 32, 32, 34, 34, 36, 36, 38, 38, 40, 40, 42, 42, 44, 44, 46, 46, 48, 48, 50, 50, 52, 52, 54, 54, 56, 56, 58, 58, 60, 60, 62, 62, 64, 64, 66, 66, 68, 68, 70, 70, 72, 72, 74, 74, 76, 76, 78, 78, 80, 80, 82, 82, 84, 84, 86, 86, 88, 88, 90, 90, 92, 92, 94, 94, 96, 96, 98, 98, 100, 100, 102, 102, 104, 104, 106, 106, 108, 108, 110, 110, 112, 112, 114, 114, 116, 116, 118, 118, 120, 120, 122, 122, 124, 124, 126, 126, 129, 129, 131, 131, 133, 133, 135, 135, 137, 137, 139, 139, 141, 141, 143, 143, 145, 145, 147, 147, 149, 149, 151, 151, 153, 153, 155, 155, 157, 157, 159, 159, 161, 161, 163, 163, 165, 165, 167, 167, 169, 169, 171, 171, 173, 173, 175, 175, 177, 177, 179, 179, 181, 181, 183, 183, 185, 185, 187, 187, 189, 189, 191, 191, 193, 193, 195, 195, 197, 197, 199, 199, 201, 201, 203, 203, 205, 205, 207, 207, 209, 209, 211, 211, 213, 213, 215, 215, 217, 217, 219, 219, 221, 221, 223, 223, 225, 225, 227, 227, 229, 229, 231, 231, 233, 233, 235, 235, 237, 237, 239, 239, 241, 241, 243, 243, 245, 245, 247, 247, 249, 249, 251, 251, 253, 253, 255, 255 };

        /// <summary>
        /// Loads any image from disk into memory and redraws it in one of the supported pixel formats, so it will never give any error (in theory).
        /// </summary>
        /// <param name="Lector">Any valid stream like a FileStream or MemoryStream that contains a valid image inside.</param>
        /// <param name="Alfa">If it's Indeterminate the returned image will contain alpha (transparency) only it if had it before. If it's Checked the returned image will always have alpha. Otherwise it will never have alpha.</param>
        /// <returns>The redrawed image in one of the supported pixel formats.</returns>
        internal static Bitmap Cargar_Imagen_Lector(Stream Lector, CheckState Alfa)
        {
            try
            {
                Image Imagen_Original = null;
                try { Imagen_Original = Image.FromStream(Lector, false, false); }
                catch { Imagen_Original = null; }
                if (Imagen_Original != null)
                {
                    int Ancho = Imagen_Original.Width;
                    int Alto = Imagen_Original.Height;
                    Bitmap Imagen = new Bitmap(Ancho, Alto, Alfa == CheckState.Unchecked ? PixelFormat.Format24bppRgb : Alfa == CheckState.Checked ? PixelFormat.Format32bppArgb : (!Image.IsAlphaPixelFormat(Imagen_Original.PixelFormat) ? PixelFormat.Format24bppRgb : PixelFormat.Format32bppArgb));
                    Graphics Pintar = Graphics.FromImage(Imagen);
                    Pintar.CompositingMode = CompositingMode.SourceCopy;
                    Pintar.CompositingQuality = CompositingQuality.HighQuality;
                    Pintar.InterpolationMode = InterpolationMode.HighQualityBicubic;
                    Pintar.PixelOffsetMode = PixelOffsetMode.HighQuality;
                    Pintar.SmoothingMode = SmoothingMode.HighQuality;
                    Pintar.TextRenderingHint = TextRenderingHint.AntiAlias;
                    Pintar.DrawImage(Imagen_Original, new Rectangle(0, 0, Ancho, Alto), new Rectangle(0, 0, Ancho, Alto), GraphicsUnit.Pixel);
                    Pintar.Dispose();
                    Pintar = null;
                    Imagen_Original.Dispose();
                    Imagen_Original = null;
                    return Imagen;
                }
            }
            catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); }
            return null;
        }

        /// <summary>
        /// Combines the desired 256 bytes arrays into one, used to apply at once multiple filters like logarithm and square root. Note: this 256 bytes array is designed to work with images, but it can also work with sound or any binary value actually, but remember that using other filters than negative or base 2, 4 or 16 bit inversions (and a few other ones), 2 times in a row won't give back the original byte values, so be aware of that.
        /// </summary>
        /// <param name="Matrices_Bytes_Filtros">Any array made up of byte arrays with 256 bytes each.</param>
        /// <returns>Returns a 256 bytes array with all the filters at once. Returns null on any error.</returns>
        internal static byte[] Combinar_Matrices_Bytes_Filtros(byte[][] Matrices_Bytes_Filtros)
        {
            try
            {
                byte[] Matriz_Bytes_Filtros = new byte[256];
                for (int Índice = 0; Índice < 256; Índice++)
                {
                    Matriz_Bytes_Filtros[Índice] = (byte)Índice; // Start with the default values.
                }
                if (Matrices_Bytes_Filtros != null && Matrices_Bytes_Filtros.Length > 0)
                {
                    for (int Índice_Filtro = 0; Índice_Filtro < Matrices_Bytes_Filtros.Length; Índice_Filtro++)
                    {
                        // Ignore the null or empty byte arrays.
                        if (Matrices_Bytes_Filtros[Índice_Filtro] != null && Matrices_Bytes_Filtros[Índice_Filtro].Length >= 256)
                        {
                            for (int Índice = 0; Índice < 256; Índice++)
                            {
                                // Adapt each time the start values to get the finished ones.
                                Matriz_Bytes_Filtros[Índice] = Matrices_Bytes_Filtros[Índice_Filtro][Matriz_Bytes_Filtros[Índice]];
                            }
                        }
                    }
                }
                return Matriz_Bytes_Filtros; // Return the combined byte array with all the filters.
            }
            catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); }
            return null;
        }

        /// <summary>
        /// Copies into the clipboard any valid text.
        /// </summary>
        /// <param name="Texto">Any valid text.</param>
        /// <returns>Returns true if the text was supposedly copied to the clipboard. Returns false otherwise.</returns>
        internal static bool Copiar_Texto_Portapapeles(string Texto)
        {
            try
            {
                if (!string.IsNullOrEmpty(Texto))
                {
                    Clipboard.SetText(Texto);
                    return true;
                }
            }
            catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); }
            return false;
        }

        /// <summary>
        /// Converts any byte array into C# code.
        /// Warning: not recommended for arrays bigger than 65.536 elements.
        /// </summary>
        /// <param name="Matriz_Bytes">Any valid byte array with at least some element in it.</param>
        /// <returns>Returns the byte array converted into a single line of text. Returns null on any error.</returns>
        internal static string Traducir_Matriz_Bytes(byte[] Matriz_Bytes)
        {
            try
            {
                if (Matriz_Bytes != null && Matriz_Bytes.Length > 0)
                {
                    string Texto = "internal static readonly byte[] Matriz_Bytes_Filtro_ = new byte[256] { ";
                    foreach (byte Valor in Matriz_Bytes)
                    {
                        try { Texto += Valor.ToString() + ", "; }
                        catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); continue; }
                    }
                    Texto = Texto.TrimEnd(", ".ToCharArray()) + " };";
                    return Texto;
                }
            }
            catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); }
            return null;
        }

        /// <summary>
        /// Creates all the directories is the specified path if they don't exist yet, without showing any exception.
        /// </summary>
        /// <param name="Ruta">Any valid directory path.</param>
        /// <returns>Returns true if the specified directories in the path now exist. Returns false on any exception, possibly indicating that the directories might not exist.</returns>
        internal static bool Crear_Carpetas(string Ruta)
        {
            try
            {
                if (!Directory.Exists(Ruta))
                {
                    Directory.CreateDirectory(Ruta);
                    return Directory.Exists(Ruta);
                }
                else return true;
            }
            catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); }
            return false;
        }

        /// <summary>
        /// Executes the specified file, directory or URL, with the specified window style.
        /// </summary>
        /// <param name="Ruta">Any valid file or directory path.</param>
        /// <param name="Estado">Any valid window style.</param>
        /// <returns>Returns true if the process can be executed. Returns false if it can't be executed.</returns>
        internal static bool Ejecutar_Ruta(string Ruta, ProcessWindowStyle Estado)
        {
            try
            {
                if (!string.IsNullOrEmpty(Ruta))
                {
                    Process Proceso = new Process();
                    Proceso.StartInfo.Arguments = null;
                    Proceso.StartInfo.ErrorDialog = false;
                    Proceso.StartInfo.FileName = Ruta;
                    Proceso.StartInfo.UseShellExecute = true;
                    Proceso.StartInfo.Verb = "open";
                    Proceso.StartInfo.WindowStyle = Estado;
                    if (File.Exists(Ruta)) Proceso.StartInfo.WorkingDirectory = Ruta;
                    else if (Directory.Exists(Ruta)) Proceso.StartInfo.WorkingDirectory = Ruta;
                    bool Resultado;
                    try { Resultado = Proceso.Start(); }
                    catch { Resultado = false; }
                    Proceso.Close();
                    Proceso.Dispose();
                    Proceso = null;
                    return Resultado;
                }
            }
            catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); }
            return false;
        }

        /// <summary>
        /// Used mostly to obtain a JPEG codec to export images with the desired compression.
        /// </summary>
        /// <param name="Identificador">Use ImageFormat.Jpeg.Guid.</param>
        /// <returns>Returns the codec used to export images with the specified format.</returns>
        internal static ImageCodecInfo Obtener_Imagen_Codificador_Guid(Guid Identificador)
        {
            try
            {
                ImageCodecInfo[] Matriz_Codificadores = ImageCodecInfo.GetImageEncoders();
                if (Matriz_Codificadores != null && Matriz_Codificadores.Length > 0)
                {
                    for (int Índice = 0; Índice < Matriz_Codificadores.Length; Índice++)
                    {
                        try
                        {
                            if (Matriz_Codificadores[Índice].FormatID == Identificador)
                            {
                                return Matriz_Codificadores[Índice];
                            }
                        }
                        catch { continue; }
                    }
                }
            }
            catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); }
            return null;
        }

        internal static Color Obtener_Color_Puro_0_a_11(int Matiz)
        {
            try
            {
                if (Matiz == 0) return Color.FromArgb(255, 0, 0);
                else if (Matiz == 1) return Color.FromArgb(255, 160, 0);
                else if (Matiz == 2) return Color.FromArgb(255, 255, 0);
                else if (Matiz == 3) return Color.FromArgb(160, 255, 0);
                else if (Matiz == 4) return Color.FromArgb(0, 255, 0);
                else if (Matiz == 5) return Color.FromArgb(0, 255, 160);
                else if (Matiz == 6) return Color.FromArgb(0, 255, 255);
                else if (Matiz == 7) return Color.FromArgb(0, 160, 255);
                else if (Matiz == 8) return Color.FromArgb(0, 0, 255);
                else if (Matiz == 9) return Color.FromArgb(160, 0, 255);
                else if (Matiz == 10) return Color.FromArgb(255, 0, 255);
                else if (Matiz == 11) return Color.FromArgb(255, 0, 160);
            }
            catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); }
            return Color.FromArgb(255, 255, 255);
        }

        /// <summary>
        /// Function that returns one of the 1.530 possible 24 bits RGB colors with full saturation and middle brightness.
        /// </summary>
        /// <param name="Índice">Any value between 0 and 1529. Red = 0, Yellow = 255, Green = 510, Cyan = 765, blue = 1020, purple = 1275. If the value is below 0 or above 1529, pure white will be returned instead.</param>
        /// <returns>Returns an ARGB color based on the selected index, or white if out of bounds.</returns>
        internal static Color Obtener_Color_Puro_1530(int Índice)
        {
            try
            {
                if (Índice >= 0 && Índice <= 1529)
                {
                    if (Índice < 255) return Color.FromArgb(255, Índice, 0);
                    else if (Índice < 510) return Color.FromArgb(510 - Índice, 255, 0);
                    else if (Índice < 765) return Color.FromArgb(0, 255, 255 - (765 - Índice));
                    else if (Índice < 1020) return Color.FromArgb(0, 1020 - Índice, 255);
                    else if (Índice < 1275) return Color.FromArgb(255 - (1275 - Índice), 0, 255);
                    else return Color.FromArgb(255, 0, 1530 - Índice);
                }
            }
            catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); }
            return Color.FromArgb(255, 255, 255);
        }

        internal static string Obtener_Nombre_Temporal()
        {
            try
            {
                DateTime Fecha = DateTime.Now;
                string Año = Fecha.Year.ToString();
                string Mes = Fecha.Month.ToString();
                string Día = Fecha.Day.ToString();
                string Hora = Fecha.Hour.ToString();
                string Minuto = Fecha.Minute.ToString();
                string Segundo = Fecha.Second.ToString();
                string Milisegundo = Fecha.Millisecond.ToString();
                while (Año.Length < 4) Año = '0' + Año;
                while (Mes.Length < 2) Mes = '0' + Mes;
                while (Día.Length < 2) Día = '0' + Día;
                while (Hora.Length < 2) Hora = '0' + Hora;
                while (Minuto.Length < 2) Minuto = '0' + Minuto;
                while (Segundo.Length < 2) Segundo = '0' + Segundo;
                while (Milisegundo.Length < 3) Milisegundo = '0' + Milisegundo;
                return Año + "_" + Mes + "_" + Día + "_" + Hora + "_" + Minuto + "_" + Segundo + "_" + Milisegundo;
            }
            catch { }
            return "0000_00_00_00_00_00_000";
        }

        internal static string Traducir_Fecha_Hora(DateTime Fecha)
        {
            try
            {
                if (Fecha != null && Fecha >= DateTime.MinValue && Fecha <= DateTime.MaxValue)
                {
                    string Año = Fecha.Year.ToString();
                    string Mes = Fecha.Month.ToString();
                    string Día = Fecha.Day.ToString();
                    string Hora = Fecha.Hour.ToString();
                    string Minuto = Fecha.Minute.ToString();
                    string Segundo = Fecha.Second.ToString();
                    string Milisegundo = Fecha.Millisecond.ToString();
                    while (Año.Length < 4) Año = "0" + Año;
                    while (Mes.Length < 2) Mes = "0" + Mes;
                    while (Día.Length < 2) Día = "0" + Día;
                    while (Hora.Length < 2) Hora = "0" + Hora;
                    while (Minuto.Length < 2) Minuto = "0" + Minuto;
                    while (Segundo.Length < 2) Segundo = "0" + Segundo;
                    while (Milisegundo.Length < 3) Milisegundo = "0" + Milisegundo;
                    return Día + "-" + Mes + "-" + Año + ", " + Hora + ":" + Minuto + ":" + Segundo + "." + Milisegundo;
                }
            }
            catch (Exception Excepción) { Application.OnThreadException(Excepción); }
            return "??-??-????, ??:??:??.???";
        }

        internal static string Traducir_Número(sbyte Valor)
        {
            return Valor.ToString();
        }

        internal static string Traducir_Número(byte Valor)
        {
            return Valor.ToString();
        }

        internal static string Traducir_Número(short Valor)
        {
            return Valor > -1000 && Valor < 1000 ? Valor.ToString() : Traducir_Número(Valor.ToString());
        }

        internal static string Traducir_Número(ushort Valor)
        {
            return Valor < 1000 ? Valor.ToString() : Traducir_Número(Valor.ToString());
        }

        internal static string Traducir_Número(int Valor)
        {
            return Valor > -1000 && Valor < 1000 ? Valor.ToString() : Traducir_Número(Valor.ToString());
        }

        internal static string Traducir_Número(uint Valor)
        {
            return Valor < 1000 ? Valor.ToString() : Traducir_Número(Valor.ToString());
        }

        internal static string Traducir_Número(long Valor)
        {
            return Valor > -1000L && Valor < 1000L ? Valor.ToString() : Traducir_Número(Valor.ToString());
        }

        internal static string Traducir_Número(ulong Valor)
        {
            return Valor < 1000UL ? Valor.ToString() : Traducir_Número(Valor.ToString());
        }

        internal static string Traducir_Número(float Valor)
        {
            //if (Single.IsNegativeInfinity(Valor)) return "-?";
            //else if (Single.IsPositiveInfinity(Valor)) return "+?";
            //else if (Single.IsNaN(Valor)) return "?";
            if (float.IsInfinity(Valor) || float.IsNaN(Valor)) return "0";
            else return Valor > -1000f && Valor < 1000f ? Valor.ToString().Replace(Caracter_Coma_Decimal, ',') : Traducir_Número(Valor.ToString());
        }

        internal static string Traducir_Número(double Valor)
        {
            //if (Double.IsNegativeInfinity(Valor)) return "-?";
            //else if (Double.IsPositiveInfinity(Valor)) return "+?";
            //else if (Double.IsNaN(Valor)) return "?";
            if (double.IsInfinity(Valor) || double.IsNaN(Valor)) return "0";
            else return Valor > -1000d && Valor < 1000d ? Valor.ToString().Replace(Caracter_Coma_Decimal, ',') : Traducir_Número(Valor.ToString());
        }

        internal static string Traducir_Número(decimal Valor)
        {
            return Valor > -1000m && Valor < 1000m ? Valor.ToString().Replace(Caracter_Coma_Decimal, ',') : Traducir_Número(Valor.ToString());
        }

        internal static string Traducir_Número(string Texto)
        {
            Texto = Texto.Replace(Caracter_Coma_Decimal, ',').Replace(".", null);
            for (int Índice = !Texto.Contains(",") ? Texto.Length - 3 : Texto.IndexOf(',') - 3, Índice_Final = !Texto.StartsWith("-") ? 0 : 1; Índice > Índice_Final; Índice -= 3) Texto = Texto.Insert(Índice, ".");
            return Texto;
            /*Texto = Texto.Replace(Caracter_Coma_Decimal, ',');
            if (Texto.Contains(".")) Texto = Texto.Replace(".", null);
            int Índice = Texto.IndexOf(',');
            for (Índice = Índice < 0 ? Texto.Length - 3 : Índice - 3; Índice > (Texto[0] != '-' ? 0 : 1); Índice -= 3) Texto = Texto.Insert(Índice, ".");
            return Texto;*/
        }

        internal static string Traducir_Número_Decimales_Redondear(double Valor, int Decimales)
        {
            Valor = Math.Round(Valor, Decimales, MidpointRounding.AwayFromZero);
            string Texto = double.IsInfinity(Valor) || double.IsNaN(Valor) ? "0" : Valor > -1000d && Valor < 1000d ? Valor.ToString().Replace(Caracter_Coma_Decimal, ',') : Traducir_Número(Valor.ToString());
            if (Texto.Contains(",") == false) Texto += ',' + new string('0', Decimales);
            else
            {
                Decimales = Decimales - (Texto.Length - (Texto.IndexOf(',') + 1));
                if (Decimales > 0) Texto += new string('0', Decimales);
            }
            return Texto;
        }

        internal static string Traducir_Tamaño_Bytes_Automático(long Tamaño_Bytes, int Decimales, bool Decimales_Cero)
        {
            try
            {
                decimal Valor = (decimal)Tamaño_Bytes;
                int Índice = 0;
                for (; Índice < 7; Índice++)
                {
                    if (Valor < 1024m) break;
                    else Valor = Valor / 1024m;
                }
                string Texto = Traducir_Número(Math.Round(Valor, Decimales, MidpointRounding.AwayFromZero));
                if (Decimales_Cero)
                {
                    if (!Texto.Contains(Caracter_Coma_Decimal.ToString())) Texto += ',' + new string('0', Decimales);
                    else
                    {
                        Decimales = Decimales - (Texto.Length - (Texto.IndexOf(Caracter_Coma_Decimal) + 1));
                        if (Decimales > 0) Texto += new string('0', Decimales);
                    }
                }
                if (Índice == 0) Texto += Tamaño_Bytes == 1L ? " Byte" : " Bytes";
                else if (Índice == 1) Texto += " KB";
                else if (Índice == 2) Texto += " MB";
                else if (Índice == 3) Texto += " GB";
                else if (Índice == 4) Texto += " TB";
                else if (Índice == 5) Texto += " PB";
                else if (Índice == 6) Texto += " EB";
                return Texto;
            }
            catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); }
            return "? Bytes";
        }

        internal static class HSL
        {
            /// <summary>
            /// Convierte un color RGB en uno HSL.
            /// </summary>
            /// <param name="Rojo">Valor entre 0 y 255.</param>
            /// <param name="Verde">Valor entre 0 y 255.</param>
            /// <param name="Azul">Valor entre 0 y 255.</param>
            /// <param name="Matiz">Valor entre 0 y 360.</param>
            /// <param name="Saturación">Valor entre 0 y 100.</param>
            /// <param name="Luminosidad">Valor entre 0 y 100.</param>
            internal static void From_RGB(byte Rojo, byte Verde, byte Azul, out double Matiz, out double Saturación, out double Luminosidad)
            {
                Matiz = 0d;
                Saturación = 0d;
                Luminosidad = 0d;
                double Rojo_1 = Rojo / 255d;
                double Verde_1 = Verde / 255d;
                double Azul_1 = Azul / 255d;
                double Máximo, Mínimo, Diferencia;
                Máximo = Math.Max(Rojo_1, Math.Max(Verde_1, Azul_1));
                Mínimo = Math.Min(Rojo_1, Math.Min(Verde_1, Azul_1));
                Luminosidad = (Mínimo + Máximo) / 2d;
                if (Luminosidad <= 0d) return;
                Diferencia = Máximo - Mínimo;
                Saturación = Diferencia;
                if (Saturación > 0d) Saturación /= (Luminosidad <= 0.5d) ? (Máximo + Mínimo) : (2d - Máximo - Mínimo);
                else
                {
                    //Luminosidad = Math.Round(Luminosidad * 100d, 1, MidpointRounding.AwayFromZero);
                    Luminosidad *= Luminosidad * 100d;
                    return;
                }
                double Rojo_2 = (Máximo - Rojo_1) / Diferencia;
                double Verde_2 = (Máximo - Verde_1) / Diferencia;
                double Azul_2 = (Máximo - Azul_1) / Diferencia;
                if (Rojo_1 == Máximo) Matiz = (Verde_1 == Mínimo ? 5d + Azul_2 : 1d - Verde_2);
                else if (Verde_1 == Máximo) Matiz = (Azul_1 == Mínimo ? 1d + Rojo_2 : 3d - Azul_2);
                else Matiz = (Rojo_1 == Mínimo ? 3d + Verde_2 : 5d - Rojo_2);
                Matiz /= 6d;
                if (Matiz >= 1d) Matiz = 0d;
                Matiz *= 360d;
                Saturación *= 100d;
                Luminosidad *= 100d;
                //if (Matiz < 0d || Matiz >= 360d) MessageBox.Show("To Matiz", Matiz.ToString());
                //if (Saturación < 0d || Saturación > 100d) MessageBox.Show("To Saturación");
                //if (Luminosidad < 0d || Luminosidad > 100d) MessageBox.Show("To Luminosidad");
                //Matiz = Math.Round(Matiz * 360d, 1, MidpointRounding.AwayFromZero); // 0.0d ~ 360.0d
                //Saturación = Math.Round(Saturación * 100d, 1, MidpointRounding.AwayFromZero); // 0.0d ~ 100.0d
                //Luminosidad = Math.Round(Luminosidad * 100d, 1, MidpointRounding.AwayFromZero); // 0.0d ~ 100.0d
                //if (Matiz >= 360d) Matiz = 0d;
            }

            /// <summary>
            /// Convierte un color HSL en uno RGB.
            /// </summary>
            /// <param name="Matiz">Valor entre 0 y 360.</param>
            /// <param name="Saturación">Valor entre 0 y 100.</param>
            /// <param name="Luminosidad">Valor entre 0 y 100.</param>
            /// <param name="Rojo">Valor entre 0 y 255.</param>
            /// <param name="Verde">Valor entre 0 y 255.</param>
            /// <param name="Azul">Valor entre 0 y 255.</param>
            internal static void To_RGB(double Matiz, double Saturación, double Luminosidad, out byte Rojo, out byte Verde, out byte Azul)
            {
                if (Matiz >= 360d) Matiz = 0d;
                //Matiz = Math.Round(Matiz, 1, MidpointRounding.AwayFromZero);
                //Saturación = Math.Round(Saturación, 1, MidpointRounding.AwayFromZero);
                //Luminosidad = Math.Round(Luminosidad, 1, MidpointRounding.AwayFromZero);
                Matiz /= 360d; // 0.0d ~ 1.0d
                Saturación /= 100d; // 0.0d ~ 1.0d
                Luminosidad /= 100d; // 0.0d ~ 1.0d
                double Rojo_Temporal = Luminosidad; // Default to Gray
                double Verde_Temporal = Luminosidad;
                double Azul_Temporal = Luminosidad;
                double v = Luminosidad <= 0.5d ? (Luminosidad * (1d + Saturación)) : (Luminosidad + Saturación - Luminosidad * Saturación);
                if (v > 0d)
                {
                    double m, sv, Sextante, fract, vsf, mid1, mid2;
                    m = Luminosidad + Luminosidad - v;
                    sv = (v - m) / v;
                    Matiz *= 6d;
                    Sextante = Math.Floor(Matiz);
                    fract = Matiz - Sextante;
                    vsf = v * sv * fract;
                    mid1 = m + vsf;
                    mid2 = v - vsf;
                    if (Sextante == 0d)
                    {
                        Rojo_Temporal = v;
                        Verde_Temporal = mid1;
                        Azul_Temporal = m;
                    }
                    else if (Sextante == 1d)
                    {
                        Rojo_Temporal = mid2;
                        Verde_Temporal = v;
                        Azul_Temporal = m;
                    }
                    else if (Sextante == 2d)
                    {
                        Rojo_Temporal = m;
                        Verde_Temporal = v;
                        Azul_Temporal = mid1;
                    }
                    else if (Sextante == 3d)
                    {
                        Rojo_Temporal = m;
                        Verde_Temporal = mid2;
                        Azul_Temporal = v;
                    }
                    else if (Sextante == 4d)
                    {
                        Rojo_Temporal = mid1;
                        Verde_Temporal = m;
                        Azul_Temporal = v;
                    }
                    else if (Sextante == 5d)
                    {
                        Rojo_Temporal = v;
                        Verde_Temporal = m;
                        Azul_Temporal = mid2;
                    }
                }
                Rojo = (byte)Math.Round(Rojo_Temporal * 255d, MidpointRounding.AwayFromZero);
                Verde = (byte)Math.Round(Verde_Temporal * 255d, MidpointRounding.AwayFromZero);
                Azul = (byte)Math.Round(Azul_Temporal * 255d, MidpointRounding.AwayFromZero);
            }

            /// <summary>
            /// Obtains a hue value between 0 and 11 for the specified color, or 12 if it's in gray scale.
            /// </summary>
            /// <param name="Rojo">Red value between 0 and 255.</param>
            /// <param name="Verde">Green value between 0 and 255.</param>
            /// <param name="Azul">Blue value between 0 and 255.</param>
            /// <returns>Returns a value between 0 and 11, or 12 if the color it's in gray scale or on any error.</returns>
            internal static int Obtener_Matiz_0_a_11(byte Rojo, byte Verde, byte Azul)
            {
                try
                {
                    if (Rojo != Verde || Rojo != Azul) // Not gray.
                    {
                        double Rojo_1 = Rojo / 255d;
                        double Verde_1 = Verde / 255d;
                        double Azul_1 = Azul / 255d;
                        double Mínimo = Math.Min(Rojo_1, Math.Min(Verde_1, Azul_1));
                        double Máximo = Math.Max(Rojo_1, Math.Max(Verde_1, Azul_1));
                        double Diferencia = Máximo - Mínimo;
                        double Rojo_2 = (Máximo - Rojo_1) / Diferencia;
                        double Verde_2 = (Máximo - Verde_1) / Diferencia;
                        double Azul_2 = (Máximo - Azul_1) / Diferencia;
                        double Matiz_Temporal = 0d;
                        if (Rojo_1 == Máximo) Matiz_Temporal = (Verde_1 == Mínimo ? 5d + Azul_2 : 1d - Verde_2);
                        else if (Verde_1 == Máximo) Matiz_Temporal = (Azul_1 == Mínimo ? 1d + Rojo_2 : 3d - Azul_2);
                        else Matiz_Temporal = (Rojo_1 == Mínimo ? 3d + Verde_2 : 5d - Rojo_2);
                        if (Matiz_Temporal >= 6d) Matiz_Temporal = 0d;
                        int Matiz = (int)(Matiz_Temporal * 510d);
                        //int Matiz = (int)(Matiz_Temporal * 2d);
                        if (Matiz >= 0 || Matiz <= 1529)
                        {
                            if (Matiz > 2933 || Matiz <= 128) return 0;
                            else if (Matiz <= 383) return 1;
                            else if (Matiz <= 638) return 2;
                            else if (Matiz <= 893) return 3;
                            else if (Matiz <= 1148) return 4;
                            else if (Matiz <= 1403) return 5;
                            else if (Matiz <= 1658) return 6;
                            else if (Matiz <= 1913) return 7;
                            else if (Matiz <= 2168) return 8;
                            else if (Matiz <= 2423) return 9;
                            else if (Matiz <= 2678) return 10;
                            else return 11;
                        }
                        else Matiz = 12;
                        return Matiz;
                    }
                    /*int Matiz = Obtener_Matiz_0_a_1529(Rojo, Verde, Azul);
                    if (Matiz != 1530)
                    {
                        if (Matiz > 2933 || Matiz <= 128) return 0;
                        else if (Matiz <= 383) return 1;
                        else if (Matiz <= 638) return 2;
                        else if (Matiz <= 893) return 3;
                        else if (Matiz <= 1148) return 4;
                        else if (Matiz <= 1403) return 5;
                        else if (Matiz <= 1658) return 6;
                        else if (Matiz <= 1913) return 7;
                        else if (Matiz <= 2168) return 8;
                        else if (Matiz <= 2423) return 9;
                        else if (Matiz <= 2678) return 10;
                        else return 11;
                    }*/
                }
                catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); }
                return 12; // Gray.
            }

            /// <summary>
            /// Obtains a hue value between 0 and 1529 for the specified color, or 1530 if it's in gray scale.
            /// </summary>
            /// <param name="Rojo">Red value between 0 and 255.</param>
            /// <param name="Verde">Green value between 0 and 255.</param>
            /// <param name="Azul">Blue value between 0 and 255.</param>
            /// <returns>Returns a value between 0 and 1529, or 1530 if the color it's in gray scale or on any error.</returns>
            internal static int Obtener_Matiz_0_a_1529(byte Rojo, byte Verde, byte Azul)
            {
                try
                {
                    if (Rojo != Verde || Rojo != Azul) // Not gray.
                    {
                        double Rojo_1 = Rojo / 255d;
                        double Verde_1 = Verde / 255d;
                        double Azul_1 = Azul / 255d;
                        double Mínimo = Math.Min(Rojo_1, Math.Min(Verde_1, Azul_1));
                        double Máximo = Math.Max(Rojo_1, Math.Max(Verde_1, Azul_1));
                        double Diferencia = Máximo - Mínimo;
                        double Rojo_2 = (Máximo - Rojo_1) / Diferencia;
                        double Verde_2 = (Máximo - Verde_1) / Diferencia;
                        double Azul_2 = (Máximo - Azul_1) / Diferencia;
                        double Matiz_Temporal = 0d;
                        if (Rojo_1 == Máximo) Matiz_Temporal = (Verde_1 == Mínimo ? 5d + Azul_2 : 1d - Verde_2);
                        else if (Verde_1 == Máximo) Matiz_Temporal = (Azul_1 == Mínimo ? 1d + Rojo_2 : 3d - Azul_2);
                        else Matiz_Temporal = (Rojo_1 == Mínimo ? 3d + Verde_2 : 5d - Rojo_2);
                        if (Matiz_Temporal >= 6d) Matiz_Temporal = 0d;
                        int Matiz = (int)(Matiz_Temporal * 255d);
                        if (Matiz < 0 || Matiz > 1529) Matiz = 1530;
                        return Matiz;
                    }
                    /*if (Rojo != Verde || Rojo != Azul)
                    {
                        byte Mínimo = Math.Min(Rojo, Math.Min(Verde, Azul));
                        byte Máximo = Math.Max(Rojo, Math.Max(Verde, Azul));
                        double Diferencia = (double)(Máximo - Mínimo);
                        double Matiz_Temporal = 0d;
                        if (Rojo == Máximo)
                        {
                            if (Verde == Mínimo) Matiz_Temporal = 1275d + ((double)(Máximo - Azul) / Diferencia);
                            else Matiz_Temporal = 255d - ((double)(Máximo - Verde) / Diferencia);
                        }
                        else if (Verde == Máximo)
                        {
                            if (Azul == Mínimo) Matiz_Temporal = 255d + ((double)(Máximo - Rojo) / Diferencia);
                            else Matiz_Temporal = 765d - ((double)(Máximo - Azul) / Diferencia);
                        }
                        else
                        {
                            if (Rojo == Mínimo) Matiz_Temporal = 765d + ((double)(Máximo - Verde) / Diferencia);
                            else Matiz_Temporal = 1275d - ((double)(Máximo - Rojo) / Diferencia);
                        }
                        int Matiz = (int)Matiz_Temporal;
                        if (Matiz < 0) Matiz = 0;
                        else if (Matiz > 1529) Matiz = 0;
                        return Matiz;
                    }*/
                }
                catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); }
                return 1530; // Gray.
            }

            internal static byte Obtener_Matiz_0_a_255(byte Rojo, byte Verde, byte Azul)
            {
                /*int Matiz = 0;
                int Saturación = 0;
                int Luminosidad = 0;
                //double Rojo_1 = Rojo / 255d;
                //double Verde_1 = Verde / 255d;
                //double Azul_1 = Azul / 255d;
                //double Máximo, Mínimo, Diferencia;
                int Máximo = Math.Max(Rojo, Math.Max(Verde, Azul));
                int Mínimo = Math.Min(Rojo, Math.Min(Verde, Azul));
                Luminosidad = (Mínimo + Máximo) / 2;
                if (Luminosidad <= 0) return 0;
                int Diferencia = Máximo - Mínimo;
                Saturación = Diferencia;
                if (Saturación > 0) Saturación /= (Luminosidad <= 128) ? (Máximo + Mínimo) : (510 - Máximo - Mínimo);
                else
                {
                    //Luminosidad = Math.Round(Luminosidad * 100d, 1, MidpointRounding.AwayFromZero);
                    return 0;
                }
                int Rojo_2 = (Máximo - Rojo) / Diferencia;
                int Verde_2 = (Máximo - Verde) / Diferencia;
                int Azul_2 = (Máximo - Azul) / Diferencia;
                if (Rojo == Máximo) Matiz = (Verde == Mínimo ? 1275 + Azul_2 : 255 - Verde_2);
                else if (Verde == Máximo) Matiz = (Azul == Mínimo ? 255 + Rojo_2 : 765 - Azul_2);
                else Matiz = (Rojo == Mínimo ? 765 + Verde_2 : 1275 - Rojo_2);
                if (Matiz >= 1530) Matiz = 0;
                Matiz /= 6;

                //Matiz *= 360d;
                //Saturación *= 100d;
                //Luminosidad *= 100d;



                if (Rojo != Verde || Rojo != Azul)
                {
                    int Matiz = 0;
                    Byte Mínimo = Math.Min(Rojo, Math.Min(Verde, Azul));
                    Byte Máximo = Math.Max(Rojo, Math.Max(Verde, Azul));
                    if (Rojo == Máximo) Matiz = (Verde == Mínimo ? (5 * 255) + (((Máximo - Azul) * 255) / (Máximo - Mínimo)) : (1 * 255) - (((Máximo - Verde) * 255) / (Máximo - Mínimo)));
                    else if (Verde == Máximo) Matiz = (Azul == Mínimo ? (1 * 255) + (((Máximo - Rojo) * 255) / (Máximo - Mínimo)) : (3 * 255) - (((Máximo - Azul) * 255) / (Máximo - Mínimo)));
                    else Matiz = (Rojo == Mínimo ? (3 * 255) + (((Máximo - Verde) * 255) / (Máximo - Mínimo)) : (5 * 255) - (((Máximo - Rojo) * 255) / (Máximo - Mínimo)));
                    Matiz++; // 2013_02_10_09_13_04_593
                    if (Matiz >/*=*//* 1530) Matiz = 0;
                    return (Byte)(Matiz / 6);
                }*/
                return 0;
            }

            internal static byte Obtener_Saturación_0_a_255(byte Rojo, byte Verde, byte Azul)
            {
                if (Rojo != Verde || Rojo != Azul)
                {
                    byte Mínimo = Math.Min(Rojo, Math.Min(Verde, Azul));
                    byte Máximo = Math.Max(Rojo, Math.Max(Verde, Azul));
                    return (byte)(((Máximo - Mínimo) * 255) / ((((Mínimo + Máximo) / 2) <= 128) ? (Máximo + Mínimo) : (510 - Máximo - Mínimo)));
                }
                return 0;
            }

            internal static byte Obtener_Brillo_0_a_255(byte Rojo, byte Verde, byte Azul)
            {
                return (byte)((Math.Min(Rojo, Math.Min(Verde, Azul)) + Math.Max(Rojo, Math.Max(Verde, Azul))) / 2);
            }
        }

        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            try
            {
                Application.EnableVisualStyles();
                Application.SetCompatibleTextRenderingDefault(false);
                Depurador.Iniciar_Depurador();
                try { Rendimiento_Procesador = new PerformanceCounter("Processor", "% Processor Time", "_Total", true); }
                catch { Rendimiento_Procesador = null; }
                Application.Run(new Ventana_Principal());
            }
            catch (Exception Excepción) { Depurador.Escribir_Excepción(Excepción != null ? Excepción.ToString() : null); }
        }
    }
}
